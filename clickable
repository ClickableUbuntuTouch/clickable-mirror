#!/usr/bin/env python2

import argparse
import subprocess
import shlex
import os
import json
import shutil

# TODO better help text & version
parser = argparse.ArgumentParser(description='clickable')
parser.add_argument('commands', nargs='*')
args = parser.parse_args()

# TODO print command output and catch errors
# TODO add command to tail the logfile
# TODO generate clickable.json file
# TODO add Golang template
# TODO add desktop arch
# TODO allow ssh ip to be passed in via cli arg


class Config(object):
    package = None
    app = None
    sdk = 'ubuntu-sdk-15.04'
    arch = 'armhf'
    prebuild = None
    template = None
    premake = None
    build = None
    postbuild = None
    launch = None
    dir = './build/'
    ssh = False
    kill = None

    required = ['package', 'app', 'sdk', 'arch', 'template', 'dir']
    keys = ['package', 'app', 'sdk', 'arch', 'prebuild', 'template', 'premake', 'build', 'postbuild', 'launch', 'dir', 'ssh', 'kill']

    PURE_QML_QMAKE = 'pure-qml-qmake'
    QMAKE = 'qmake'
    PURE_QML_CMAKE = 'pure-qml-cmake'
    CMAKE = 'cmake'
    CUSTOM = 'custom'
    CORDOVA = 'cordova'

    # TODO add pure qml (qml only)
    templates = [PURE_QML_CMAKE, QMAKE, PURE_QML_CMAKE, CMAKE, CUSTOM, CORDOVA]

    def __init__(self):
        self.cwd = os.getcwd()
        self.load_config()

    def load_config(self, file='clickable.json'):
        with open(os.path.join(self.cwd, file), 'r') as f:
            config_json = {}
            try:
                config_json = json.load(f)
            except ValueError:
                raise ValueError('Failed reading "{}", it is not valid json'.format(file))

            for key in self.keys:
                value = config_json.get(key, None)

                if value:
                    setattr(self, key, value)

        for key in self.required:
            if not getattr(self, key):
                raise ValueError('"{}" is empty in the config file'.format(key))

        if self.template == self.CUSTOM and not self.build:
            raise ValueError('When using the "custom" template you must specify a "build" in the config')

        if self.template not in self.templates:
            raise ValueError('"{}" is not a valid template ({})'.format(self.template, ', '.join(self.templates)))

        if self.template == self.PURE_QML_CMAKE or self.template == self.PURE_QML_QMAKE:
            self.arch = 'all'

        self.dir = os.path.abspath(self.dir)


class Clickable(object):
    cwd = None

    def __init__(self, config):
        self.cwd = os.getcwd()
        self.config = config
        self.temp = '/tmp/clickable-build-{}'.format(self.config.package)
        self.build_arch = self.config.arch
        if self.config.template == self.config.PURE_QML_QMAKE or self.config.template == self.config.PURE_QML_CMAKE:
            self.build_arch = 'armhf'

    def find_version(self):
        with open(os.path.join(self.config.dir, 'manifest.json'), 'r') as f:
            manifest = {}
            try:
                manifest = json.load(f)
            except ValueError:
                raise ValueError('Failed reading "manifest.json", it is not valid json')

            return manifest.get('version', '1.0')

        return '1.0'

    def run_device_command(self, command):
        wrapped_command = ''
        if self.config.ssh:
            wrapped_command = '{} | ssh phablet@{}'.format(command, self.config.ssh)
        else:
            wrapped_command = '{} | phablet-shell'.format(command)

        subprocess.check_call(wrapped_command, cwd=self.config.dir, shell=True)

    def qmake(self):
        if self.build_arch == 'armhf':
            command = 'click chroot -a {} -f {} run qt5-qmake-arm-linux-gnueabihf {}'.format(self.build_arch, self.config.sdk, self.cwd)
            subprocess.check_call(shlex.split(command), cwd=self.config.dir)
        else:
            # TODO implement this
            raise Exception('{} is not supported by the qmake build yet'.format(self.build_arch))

    def cmake(self):
        command = 'click chroot -a {} -f {} run cmake {}'.format(self.build_arch, self.config.sdk, self.cwd)
        subprocess.check_call(shlex.split(command), cwd=self.config.dir)

    def make(self):
        command = 'click chroot -a {} -f {} run make'.format(self.build_arch, self.config.sdk)
        subprocess.check_call(shlex.split(command), cwd=self.config.dir)

    def make_install(self):
        if os.path.exists(self.temp) and os.path.isdir(self.temp):
            shutil.rmtree(self.temp)

        try:
            os.makedirs(self.temp)
        except:
            pass  # TODO do something meaningful

        if self.config.template == self.config.QMAKE or self.config.template == self.config.PURE_QML_QMAKE:
            command = 'click chroot -a {} -f {} run make INSTALL_ROOT={} install'.format(self.build_arch, self.config.sdk, self.temp)
            subprocess.check_call(shlex.split(command), cwd=self.config.dir)

        elif self.config.template == self.config.CMAKE or self.config.template == self.config.PURE_QML_CMAKE:
            command = 'click chroot -a {} -f {} run make DESTDIR={} install'.format(self.build_arch, self.config.sdk, self.temp)
            subprocess.check_call(shlex.split(command), cwd=self.config.dir)

    def click_build(self):
        command = 'click build {} --no-validate'.format(self.temp)
        subprocess.check_call(shlex.split(command), cwd=self.config.dir)

        self.click_review()  # TODO do something meaningful with the output

    def click_review(self):
        pass  # TODO implement this

    def install(self):
        click = '{}_{}_{}.click'.format(self.config.package, self.find_version(), self.config.arch)
        click_path = os.path.join(self.config.dir, click)

        if self.config.ssh:
            command = 'scp {} phablet@{}:/home/phablet/'.format(click_path, self.config.ssh)
            subprocess.check_call(command, cwd=self.config.dir, shell=True)

        else:
            command = 'adb push {} /home/phablet/'.format(click_path)
            subprocess.check_call(command, cwd=self.config.dir, shell=True)

        self.run_device_command('echo "pkcon install-local --allow-untrusted {}"'.format(click))

    def kill(self):
        if self.config.kill:
            try:
                self.run_device_command('echo "pkill {}"'.format(self.config.kill))
            except:
                pass  # Nothing to do, the process probably wasn't running

    def launch(self):
        launch = 'ubuntu-app-launch {}_{}_{}'.format(self.config.package, self.config.app, self.find_version())
        if self.config.launch:
            launch = self.config.launch

        self.run_device_command('echo "sleep 1s && {}"'.format(launch))

    def clean(self):
        try:
            shutil.rmtree(self.config.dir)
        except:
            pass  # TODO do something meaningful

    def build(self):
        try:
            os.makedirs(self.config.dir)
        except:
            pass  # TODO do something meaningful

        if self.config.prebuild:
            subprocess.check_call(self.config.prebuild, cwd=self.cwd, shell=True)

        if self.config.template == self.config.QMAKE or self.config.template == self.config.PURE_QML_QMAKE:
            self.qmake()
        elif self.config.template == self.config.CMAKE or self.config.template == self.config.PURE_QML_CMAKE:
            # TODO this doesn't always need to be run
            self.cmake()
        else:
            subprocess.check_call(self.config.build, cwd=self.cwd, shell=True)

        if self.config.premake:
            subprocess.check_call(self.config.premake, cwd=self.config.dir, shell=True)

        if self.config.template != self.config.CUSTOM:
            self.make()

        if self.config.postbuild:
            subprocess.check_call(self.config.postbuild, cwd=self.config.dir, shell=True)

        if self.config.template == self.config.PURE_QML_QMAKE or self.config.template == self.config.PURE_QML_CMAKE:
            with open(os.path.join(self.config.dir, 'manifest.json'), 'r') as f:
                manifest = {}
                try:
                    manifest = json.load(f)
                except ValueError:
                    raise ValueError('Failed reading "manifest.json", it is not valid json')

                manifest['architecture'] = 'all'
                with open(os.path.join(self.config.dir, 'manifest.json'), 'w') as writer:
                    json.dump(manifest, writer, indent=4)

        if self.config.template != self.config.CUSTOM:
            self.make_install()

config = Config()
clickable = Clickable(config)
commands = args.commands
if len(args.commands) == 0:
    commands = ['kill', 'clean', 'build', 'click_build', 'install', 'launch']

for command in commands:
    if command == 'kill':
        clickable.kill()

    if command == 'clean':
        clickable.clean()

    if command == 'build':
        clickable.build()

    if command == 'click_build':
        clickable.click_build()

    if command == 'install':
        clickable.install()

    if command == 'launch':
        clickable.launch()
